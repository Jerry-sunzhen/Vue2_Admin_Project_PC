## 项目前的复习

### 1. $event的理解
* 情况一: 在dom对象上,$event指代原生事件对象
* 情况二: 在组件对象上,$event指代的是子组件中使用$emit传入的第二个参数
* 情况三: 在组件对象上,如果绑定事件时候使用了  .native修饰符  则$event指代原生事件对象

### 2. 组件间数据传递方式总结
1. props
2. Vue自定义事件
3. 事件总线
4. 插槽
5. localStorage
6. vuex
7. 路由的url
8. $event
9. 在组件上使用v-model
   1. 给组件传递了一个名为value的props
   2. 给组件注册了一个自定义事件 @input="value = $event"
   3. 因此子组件可以接收到value,通过emit一个"input"事件,并传入一个值,则父组件就能通过$event接收到该值
10. v-bind.sync="foo"
    1. 本质上是给组件注册了一个自定义事件  @update:foo = "foo = $event"
    2. 给组件传递了一个名为foo的props
11. 使用v-bind={a:a,b:b}绑定一个对象传递给子组件,子组件会自动解构并获取这些props
12. 使用v-on={keyup:keyupFn,click:clickFn},给dom元素绑定多个事件回调
13. 使用$attrs可以获取到父组件传下来的非props属性组成的对象,一般与v-bind=$attrs结合使用
14. 使用$listeners可以获取到父组件上绑定的自定义事件,一般与v-on=$listeners结合使用
15. 使用$children/$parent/$root可以拿到组件的所有子组件/组件的父组件/根组件,然后调用其他组件中的方法
16. provide和inject


### 3. 插槽的使用
1. 基本插槽
2. 具名插槽
3. 作用域插槽

### 修改组件上的自定义事件为DOM原生事件
当UI库没有给组件中的元素绑定emit自定义事件的回调,
我们可以通过native修饰符直接给组件根标签绑定DOM原生事件


### 自定义实现遮罩层(借助使用自定义指令directive)
```vue
<script >
  import Vue from "vue"
  Vue.directive("my-cloak",{
    update(el,binding,vNode){
      // 如果给指令绑定的值是true,说明需要显示遮罩层
      if(binding.value === true){
        const divEl = document.createElement("div")
        divEl.id = "myCloakEl"
        divEl.innerHTML = "loading"
        const styleEl = document.createElement("style")
        styleEl.id = "myCloakStyle"
        styleEl.innerHTML = `#myCloakEl{
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 9999;
          background: rgba(0,0,0,.6);
      
          color: whitesmoke;
          font-size: 30px;
          font-weight: bolder;
          display: flex;
          justify-content: center;
          align-items: center;
        }`
        divEl.addEventListener("click",()=>{
          //将遮罩移除dom树 将binding.value改为false 而且还得触发update钩子
          vnode.context[binding.expression] = false;
        })
  
        //将遮罩和遮罩样式塞入到dom树中
        document.body.appendChild(styleEl)
        el.appendChild(divEl)
      }
      else{
        const styleEl = document.querySelector("#myCloakStyle")
        if(styleEl){
          document.body.removeChild(styleEl)
        }
        const myCloakEl = document.querySelector("#myCloakEl")
        if(myCloakEl){
          el.removeChild(myCloakEl)
        }
      }
    }
  })
</script>
```
在指令的钩子函数中进行DOM操作
1. 通过el可以拿到挂载了该指令的DOM对象
2. 通过binding中的expression和value可以拿到该指令指定的表达式和值
3. 通过vNode.context可以拿到该指定对应的Vue实例对象,就能拿到该实例上data配置中的数据进行修改

### 自定义实现弹出层(借助extend API 在app后面挂载/移除一个包裹Vue子类实例的DOM对象)
将loading方法挂载到Vue原型上
Vue.$loading = function(){}

extend API: 通过Vue.extend可以生成一个构造器
```js
import Vue from "vue"
const Loading = Vue.extend({
  template: "<div id='loadingToast' @click='hide'>{{msg}}</div>",
  methods:{
    hide(){
      // 将body上追加的loadingEl移除
      const loadingEl = document.querySelector("#myLoading")
      loadingEl && document.body.removeChild(loadingEl)
    }
  }
})

Vue.prototype.$loading = function(msg){
  // 在body上追加一个div用来存放extend产生子类的实例
  const LoadingEl = document.createElement("div")
  loadingEl.id = "myLoading"
  document.body.appendChild(loadingEl)
  // 实例化extend生成的子类并挂载到刚刚追加到body上的loadingEl上
  new Loading({
    props:{
      msg:{
        default:msg ?? ""
      }
    }
  }).$mount("#myLoading")
}
```



-------------------------------------------------------------

## 项目文件基本介绍

### 接口文档地址
http://39.98.123.211:8216/swagger-ui.html

### .env文件
1. .env.development      开发模式下会被设置到环境变量中的文件
2. .env.production       生产模式下会被设置到环境变量中的文件


### api接口文件结构的设置
```js
//方法一:
// 使用*的方式进行导入
import * as product from "views/product"
// 使用export方式进行导出
export { product }

// 上述代码可以简写为如下代码,
export * as product from "views/product"
// 注意:如果使用简写方式,那么最终的暴露方式都是以一个代码块而不是一个对象


// 方法二:
function a(){};function b(){}
export default {
  a,
  b
}
import product from "views/product"
// 如果是使用如下导入+导出简写的方式,实际导出的是一个代码块
export product from "views/product"
```


### request对象中拦截器的code校验
模板中的mock接口成功响应码默认为20000,项目接口返回data中的code字段为200
因此在响应拦截器中进行code校验的时候,可以使用一个数组`[20000,200].includes(data.code)`进行响应data中code校验


### vue.config.js中配置代理服务器的跨域
```js
module.exports = {
  devServer:{
    proxy:{
      "/api":{
        target:"",
        changeOrigin:true,
        pathRewrite:{
          "^/api":""
        }
      }
    }
  }
}
```

















